# Estrategia Incremental para Implementaci√≥n de Dynamic Ranges

## Resumen Ejecutivo

Estrategia de implementaci√≥n siguiendo **ATDD estricto** para cerrar el gap arquitect√≥nico en funciones de rangos din√°micos (INDEX, OFFSET, INDIRECT) en xlcalculator, basada en an√°lisis de `20250907.0058-criterios-desarrollo-atdd-completos.md`.

## An√°lisis de Brechas Root Cause

### Problemas Arquitect√≥nicos Identificados

1. **üî¥ CR√çTICO: Falta de integraci√≥n con sistema de referencias**
   - Las funciones din√°micas necesitan acceso al evaluator durante ejecuci√≥n
   - No hay mecanismo est√°ndar para pasar contexto del evaluator
   - `_set_evaluator_context()` es un workaround, no una soluci√≥n arquitectural

2. **üî¥ CR√çTICO: Manejo inadecuado de referencias din√°micas**
   - OFFSET usa hardcoded reference mapping en lugar de parsing real
   - INDIRECT no eval√∫a expresiones din√°micas (concatenaci√≥n &)
   - No integra con el sistema de parsing de referencias de xlcalculator

3. **üî¥ CR√çTICO: Falta de soporte para arrays complejos**
   - INDEX arrays (row=0, col=0) necesita Array type compatible
   - OFFSET con height/width necesita construcci√≥n de rangos din√°micos
   - No hay integraci√≥n con el sistema de rangos de xlcalculator

4. **üî¥ CR√çTICO: Evaluaci√≥n de expresiones en tiempo de ejecuci√≥n**
   - INDIRECT("Data!A" & 2) requiere evaluaci√≥n de concatenaci√≥n
   - Necesita acceso a funciones CHAR(), ROW(), COLUMN()
   - No hay mecanismo para evaluar sub-expresiones

5. **üü° IMPORTANTE: Validaci√≥n de l√≠mites de hoja**
   - OFFSET necesita conocer l√≠mites reales de la hoja
   - Validaci√≥n de referencias fuera de rango
   - Manejo de referencias a hojas inexistentes

6. **üü° IMPORTANTE: Compatibilidad de tipos**
   - Array type de xlcalculator vs tipos nativos de Python
   - Conversi√≥n entre XLRange y Array
   - Manejo de tipos Excel (Boolean, Number, Text)

### Componentes Arquitect√≥nicos Necesarios

- **Context Injection System** - Para pasar evaluator a funciones
- **Dynamic Reference Parser** - Para evaluar referencias calculadas
- **Sub-expression Evaluator** - Para INDIRECT con concatenaci√≥n
- **Dynamic Array Builder** - Para arrays de OFFSET e INDEX
- **Sheet Bounds Validator** - Para validaci√≥n de l√≠mites

## Fases de Implementaci√≥n Incremental

### FASE 0: PREPARACI√ìN ARQUITECT√ìNICA
**Objetivo:** Limpiar c√≥digo existente y preparar base  
**Duraci√≥n:** 1 ciclo  
**Acciones:**
- Eliminar implementaciones placeholder existentes
- Crear estructura base para context injection
- Preparar para ATDD estricto

### FASE 1: CONTEXT INJECTION SYSTEM
**Objetivo:** Permitir acceso al evaluator desde funciones  
**Tests:** INDEX b√°sicos (A1-A5)  
**Duraci√≥n:** 5 ciclos ATDD

### FASE 2: INDEX FUNDAMENTALS
**Objetivo:** INDEX con valores individuales  
**Tests:** INDEX casos 1A (5 tests)  
**Duraci√≥n:** 5 ciclos ATDD  

**Casos espec√≠ficos:**
- CICLO 2.1: `INDEX(Data!A1:E6, 2, 2) ‚Üí 25`
- CICLO 2.2: `INDEX(Data!A1:E6, 3, 1) ‚Üí "Bob"`
- CICLO 2.3: `INDEX(Data!A1:E6, 4, 5) ‚Üí TRUE`
- CICLO 2.4: `INDEX(Data!A1:E6, 6, 1) ‚Üí "Eve"`
- CICLO 2.5: `INDEX(Data!A1:E6, 1, 5) ‚Üí "Active"`

### FASE 3: INDEX ARRAYS
**Objetivo:** INDEX con arrays completos (row=0, col=0)  
**Tests:** INDEX casos 1B (4 tests)  
**Duraci√≥n:** 4 ciclos ATDD

**Casos espec√≠ficos:**
- CICLO 3.1: `INDEX(Data!A1:E6, 0, 2) ‚Üí Array columna Age`
- CICLO 3.2: `INDEX(Data!A1:E6, 2, 0) ‚Üí Array fila Alice`
- CICLO 3.3: `INDEX(Data!A1:E6, 0, 1) ‚Üí Array columna Name`
- CICLO 3.4: `INDEX(Data!A1:E6, 0, 5) ‚Üí Array columna Active`

### FASE 4: INDEX ERRORS
**Objetivo:** Manejo de errores en INDEX  
**Tests:** INDEX casos 1C (5 tests)  
**Duraci√≥n:** 5 ciclos ATDD

**Casos espec√≠ficos:**
- CICLO 4.1: `INDEX(Data!A1:E6, 7, 1) ‚Üí #REF!` (fila fuera de rango)
- CICLO 4.2: `INDEX(Data!A1:E6, 1, 7) ‚Üí #REF!` (columna fuera de rango)
- CICLO 4.3: `INDEX(Data!A1:E6, 0, 0) ‚Üí #VALUE!` (ambos cero)
- CICLO 4.4: `INDEX(Data!A1:E6, -1, 1) ‚Üí #VALUE!` (fila negativa)
- CICLO 4.5: `INDEX(Data!A1:E6, 1, -1) ‚Üí #VALUE!` (columna negativa)

### FASE 5: OFFSET FUNDAMENTALS
**Objetivo:** OFFSET con referencias b√°sicas  
**Tests:** OFFSET casos 2D (5 tests)  
**Duraci√≥n:** 5 ciclos ATDD

### FASE 6: OFFSET ARRAYS
**Objetivo:** OFFSET con height/width  
**Tests:** OFFSET casos 2E (5 tests)  
**Duraci√≥n:** 5 ciclos ATDD

### FASE 7: OFFSET ERRORS
**Objetivo:** Manejo de errores en OFFSET  
**Tests:** OFFSET casos 2F (6 tests)  
**Duraci√≥n:** 6 ciclos ATDD

### FASE 8: INDIRECT FUNDAMENTALS
**Objetivo:** INDIRECT con referencias b√°sicas  
**Tests:** INDIRECT casos 2G (4 tests)  
**Duraci√≥n:** 4 ciclos ATDD

### FASE 9: INDIRECT DYNAMIC
**Objetivo:** INDIRECT con concatenaci√≥n y funciones  
**Tests:** INDIRECT casos 2H (4 tests)  
**Duraci√≥n:** 4 ciclos ATDD

### FASE 10: INDIRECT ARRAYS
**Objetivo:** INDIRECT con rangos y arrays  
**Tests:** INDIRECT casos 2I (4 tests)  
**Duraci√≥n:** 4 ciclos ATDD

### FASE 11: INDIRECT FULL REFERENCES
**Objetivo:** INDIRECT con columnas/filas completas  
**Tests:** INDIRECT casos 2J (4 tests)  
**Duraci√≥n:** 4 ciclos ATDD

### FASE 12: INDIRECT ERRORS
**Objetivo:** Manejo de errores en INDIRECT  
**Tests:** INDIRECT casos 2K (5 tests)  
**Duraci√≥n:** 5 ciclos ATDD

### FASE 13: COMBINATIONS
**Objetivo:** Combinaciones INDEX+INDIRECT, OFFSET+INDIRECT  
**Tests:** Casos 3L, 3M, 3N (10 tests)  
**Duraci√≥n:** 10 ciclos ATDD

### FASE 14: CONTEXT FUNCTIONS
**Objetivo:** Uso con agregaci√≥n y manejo de errores  
**Tests:** Casos 4O, 4P (7 tests)  
**Duraci√≥n:** 7 ciclos ATDD

### FASE 15: EDGE CASES
**Objetivo:** Casos l√≠mite y referencias especiales  
**Tests:** Casos 5Q, 5R, 5S (7 tests)  
**Duraci√≥n:** 7 ciclos ATDD

**TOTAL:** 15 fases, ~75 ciclos ATDD, 75 tests de aceptaci√≥n

## Proceso ATDD Estricto

### Ciclo Obligatorio por Test

1. **RED:** Ejecutar test espec√≠fico ‚Üí debe fallar
2. **GREEN:** Implementar M√çNIMO c√≥digo ‚Üí test pasa
3. **REFACTOR:** Eliminar duplicaci√≥n ‚Üí tests siguen pasando
4. **COMMIT:** Guardar progreso ‚Üí push inmediato

### Principios Fundamentales

- ‚ùå **NO implementar c√≥digo** sin test de aceptaci√≥n fallando
- ‚ùå **NO crear tests de unidad** antes de aceptaci√≥n
- ‚ùå **NO anticipar funcionalidad** no demandada por tests
- ‚úÖ **Implementaci√≥n m√≠nima** para pasar test espec√≠fico
- ‚úÖ **Refactorizaci√≥n obligatoria** para eliminar duplicaci√≥n

### Ejemplo de Ciclo ATDD

**CICLO 2.1: INDEX(Data!A1:E6, 2, 2) = 25**

1. **RED:** 
   ```bash
   python -m pytest tests/xlfunctions_vs_excel/dynamic_ranges_test.py::DynamicRangesComprehensiveTest::test_1a -v
   # FALLA: IndexError o similar
   ```

2. **GREEN:**
   ```python
   @xl.register()
   def INDEX(array, row_num, col_num=1):
       evaluator = _get_evaluator_context()
       array_data = evaluator.get_range_values(array)
       row_idx = int(row_num) - 1
       col_idx = int(col_num) - 1
       return array_data[row_idx][col_idx]
   ```

3. **REFACTOR:**
   ```python
   def _convert_to_python_int(xl_number):
       return int(xl_number.value if hasattr(xl_number, 'value') else xl_number)
   
   @xl.register()
   def INDEX(array, row_num, col_num=1):
       evaluator = _get_evaluator_context()
       array_data = evaluator.get_range_values(array)
       row_idx = _convert_to_python_int(row_num) - 1
       col_idx = _convert_to_python_int(col_num) - 1
       return array_data[row_idx][col_idx]
   ```

4. **COMMIT:**
   ```bash
   git add .
   git commit -m "feat: INDEX basic value retrieval (numeric)

   - test_1a: INDEX(Data!A1:E6, 2, 2) = 25 passes
   - Implement array resolution with evaluator.get_range_values()
   - Refactor: Extract _convert_to_python_int() utility

   Co-authored-by: Ona <no-reply@ona.com>"
   git push origin master
   ```

## Estrategia de Refactorizaci√≥n

### Patrones de Duplicaci√≥n a Eliminar

1. **Conversi√≥n de par√°metros** ‚Üí `_convert_to_python_int()`
2. **Resoluci√≥n de referencias** ‚Üí `_parse_cell_reference()`
3. **Manejo de arrays** ‚Üí `_get_array_column()`, `_get_array_row()`
4. **Validaci√≥n de errores** ‚Üí `_validate_bounds()`, `_validate_parameters()`
5. **Construcci√≥n de referencias** ‚Üí `_build_cell_reference()`

### Criterios de Refactorizaci√≥n

- ‚úÖ Solo despu√©s de estado GREEN
- ‚úÖ Cuando aparece duplicaci√≥n (2+ usos similares)
- ‚úÖ Extraer funciones con nombres descriptivos
- ‚úÖ Mantener todos los tests pasando

### Cronograma de Refactorizaci√≥n

**FASE 2 (INDEX FUNDAMENTALS) - Refactors esperados:**
- CICLO 2.1: Extraer `_resolve_array_reference()`
- CICLO 2.2: Extraer `_convert_to_python_int()`
- CICLO 2.3: Centralizar manejo de tipos en `_handle_excel_types()`
- CICLO 2.4: Extraer `_validate_array_bounds()`
- CICLO 2.5: Consolidar indexing en `_get_array_value()`

**FASE 3 (INDEX ARRAYS) - Refactors esperados:**
- CICLO 3.1: Extraer `_get_array_column()`
- CICLO 3.2: Extraer `_get_array_row()`
- CICLO 3.3: Centralizar Array conversion en `_convert_to_xl_array()`
- CICLO 3.4: Consolidar array handling en `_handle_array_extraction()`

## Estrategia de Commit y Push

### Formato de Mensajes

```
<type>: <description>

- <specific test case that now passes>
- <implementation details>
- <refactoring applied>

Co-authored-by: Ona <no-reply@ona.com>
```

### Tipos de Commit

- `feat:` Nueva funcionalidad implementada
- `fix:` Correcci√≥n de bug espec√≠fico
- `refactor:` Refactorizaci√≥n sin cambio de comportamiento
- `test:` Cambios en tests (solo si es necesario)
- `arch:` Cambios arquitect√≥nicos fundamentales

### Ejemplos por Fase

```bash
# FASE 0
"arch: Clean dynamic_range.py and prepare ATDD foundation"

# FASE 2 - CICLO 2.1
"feat: INDEX basic value retrieval (numeric)"

# FASE 2 - CICLO 2.2
"feat: INDEX text value retrieval"

# FASE 3 - CICLO 3.1
"feat: INDEX full column extraction (row=0)"

# FASE 4 - CICLO 4.1
"feat: INDEX #REF! error for row out of bounds"
```

### Timing de Push

- ‚úÖ Push inmediato despu√©s de cada commit
- ‚úÖ No acumular m√∫ltiples commits localmente
- ‚úÖ Mantener repositorio remoto actualizado

## Criterios de √âxito

### Por Ciclo ATDD

- ‚úÖ Un test espec√≠fico pasa que antes fallaba
- ‚úÖ Todos los tests anteriores siguen pasando
- ‚úÖ C√≥digo refactorizado elimina duplicaci√≥n
- ‚úÖ Mensaje de commit es claro y trazable
- ‚úÖ Push exitoso al repositorio remoto

### Por Fase

- ‚úÖ Todos los tests de la fase pasan
- ‚úÖ Funcionalidad espec√≠fica completamente implementada
- ‚úÖ Refactorizaci√≥n aplicada elimina duplicaci√≥n
- ‚úÖ Base s√≥lida para siguiente fase

### Resultado Final Esperado

Al completar esta estrategia:
- **75 tests de aceptaci√≥n pasando** (100% cobertura del dise√±o)
- **Funciones INDEX, OFFSET, INDIRECT** completamente funcionales
- **Comportamiento fiel a Excel** en todos los casos
- **C√≥digo limpio y mantenible** sin duplicaci√≥n
- **Arquitectura robusta** para futuras extensiones

## Documentaci√≥n del Progreso

### Tracking en ona-memory/

**Archivo:** `YYYYMMDD.HHMM-atdd-progress-log.md`

**Contenido:**
- Fase actual
- Test espec√≠fico en progreso
- Estado (RED/GREEN/REFACTOR)
- Pr√≥ximo test a implementar
- Refactorings aplicados

### Ejemplo de Log de Progreso

```markdown
# ATDD Progress Log - Dynamic Ranges Implementation

## Current Status: FASE 2 - INDEX FUNDAMENTALS

### Completed:
- ‚úÖ CICLO 2.1: INDEX(Data!A1:E6, 2, 2) = 25
- ‚úÖ CICLO 2.2: INDEX(Data!A1:E6, 3, 1) = "Bob"

### In Progress:
- üîÑ CICLO 2.3: INDEX(Data!A1:E6, 4, 5) = TRUE
- State: GREEN (test passing)
- Next: REFACTOR (consolidate type handling)

### Refactorings Applied:
- _resolve_array_reference() - CICLO 2.1
- _convert_to_python_int() - CICLO 2.2

### Next Test:
- CICLO 2.4: INDEX(Data!A1:E6, 6, 1) = "Eve"
```

## Conclusi√≥n

Esta estrategia garantiza implementaci√≥n incremental, controlada y de alta calidad siguiendo principios ATDD estrictos, con trazabilidad completa entre tests y c√≥digo implementado. La arquitectura resultante ser√° robusta, mantenible y fiel al comportamiento de Excel.