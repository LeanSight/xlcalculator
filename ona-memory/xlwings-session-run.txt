
(xlcalc313) c:\workspace_local\xlcalculator\tests\resources_generator>python generate_all_xlwings.py ..\resources
ðŸ”§ Excel File Generator with xlwings
============================================================
âœ… xlwings is installed
âœ… Microsoft Excel is available

ðŸ“ Output directory: c:\workspace_local\xlcalculator\tests\resources

ðŸš€ Starting Excel file generation with xlwings...
ðŸ“‹ This will create 6 Excel files with calculated formula values
âš ï¸  Requires Windows with Microsoft Excel installed

ðŸ“ Generating INFORMATION.xlsx...
âœ… Created ..\resources\INFORMATION.xlsx with Excel calculations
âœ… Successfully created INFORMATION.xlsx

ðŸ“ Generating logical.xlsx...
âŒ Failed to create logical.xlsx: (-2147352567, 'OcurriÃ³ una excepciÃ³n.', (0, None, None, None, 0, -2146827284), None)

ðŸ“ Generating MATH.xlsx...
âœ… Created ..\resources\MATH.xlsx with Excel calculations
âœ… Successfully created MATH.xlsx

ðŸ“ Generating TEXT.xlsx...
âœ… Created ..\resources\TEXT.xlsx with Excel calculations
âœ… Successfully created TEXT.xlsx

ðŸ“ Generating XLOOKUP.xlsx...
âœ… Created ..\resources\XLOOKUP.xlsx with Excel calculations
âœ… Successfully created XLOOKUP.xlsx

ðŸ“ Generating DYNAMIC_RANGE.xlsx...
âŒ Failed to create DYNAMIC_RANGE.xlsx: (-2147352567, 'OcurriÃ³ una excepciÃ³n.', (0, None, None, None, 0, -2146827284), None)

============================================================
ðŸ“Š GENERATION SUMMARY
============================================================
âœ… Successfully created: 4 files
   - INFORMATION.xlsx
   - MATH.xlsx
   - TEXT.xlsx
   - XLOOKUP.xlsx

âŒ Failed to create: 2 files
   - logical.xlsx: (-2147352567, 'OcurriÃ³ una excepciÃ³n.', (0, None, None, None, 0, -2146827284), None)
   - DYNAMIC_RANGE.xlsx: (-2147352567, 'OcurriÃ³ una excepciÃ³n.', (0, None, None, None, 0, -2146827284), None)

ðŸ“ Output directory: c:\workspace_local\xlcalculator\tests\resources

ðŸ“‹ NEXT STEPS:
1. Copy the generated Excel files to your xlcalculator project
2. Place them in: tests/resources/
3. Run the integration tests to verify Excel compatibility

Example commands:
   copy ..\resources\*.xlsx ..\resources\
   python -m pytest tests/xlfunctions_vs_excel/ -v

ðŸ“Š Files generated:
   - INFORMATION.xlsx: IS* functions (ISNUMBER, ISTEXT, ISBLANK, etc.)
   - logical.xlsx: Logical functions (AND, OR, TRUE, FALSE)
   - MATH.xlsx: Math functions (FLOOR, TRUNC, SIGN, LOG, EXP)
   - TEXT.xlsx: Text functions (LEFT, UPPER, LOWER, TRIM, REPLACE)
   - XLOOKUP.xlsx: XLOOKUP function with all match modes
   - DYNAMIC_RANGE.xlsx: INDEX, OFFSET, INDIRECT functions

âš ï¸  Generated 4 files, 2 failed

(xlcalc313) c:\workspace_local\xlcalculator\tests\resources_generator>cd ..

(xlcalc313) c:\workspace_local\xlcalculator\tests>cd ..

(xlcalc313) c:\workspace_local\xlcalculator>pytest tests\xlfunctions_vs_excel
================================================= test session starts =================================================
platform win32 -- Python 3.13.5, pytest-8.4.1, pluggy-1.6.0
rootdir: c:\workspace_local\xlcalculator
plugins: cov-6.2.1
collected 312 items

tests\xlfunctions_vs_excel\abs_test.py .                                                                         [  0%]
tests\xlfunctions_vs_excel\acos_test.py ...                                                                      [  1%]
tests\xlfunctions_vs_excel\asin_test.py ....                                                                     [  2%]
tests\xlfunctions_vs_excel\atan2_test.py ....                                                                    [  3%]
tests\xlfunctions_vs_excel\atan_test.py ...                                                                      [  4%]
tests\xlfunctions_vs_excel\average_test.py .                                                                     [  5%]
tests\xlfunctions_vs_excel\ceiling_test.py ........                                                              [  7%]
tests\xlfunctions_vs_excel\choose_test.py ...                                                                    [  8%]
tests\xlfunctions_vs_excel\concat_test.py ......                                                                 [ 10%]
tests\xlfunctions_vs_excel\concatenate_test.py .                                                                 [ 10%]
tests\xlfunctions_vs_excel\cos_test.py ...                                                                       [ 11%]
tests\xlfunctions_vs_excel\cosh_test.py ..                                                                       [ 12%]
tests\xlfunctions_vs_excel\count_test.py ...                                                                     [ 13%]
tests\xlfunctions_vs_excel\counta_test.py ......                                                                 [ 15%]
tests\xlfunctions_vs_excel\countif_test.py .                                                                     [ 15%]
tests\xlfunctions_vs_excel\countifs_test.py .                                                                    [ 16%]
tests\xlfunctions_vs_excel\date_test.py .......................                                                  [ 23%]
tests\xlfunctions_vs_excel\datedif_test.py ......                                                                [ 25%]
tests\xlfunctions_vs_excel\day_test.py .                                                                         [ 25%]
tests\xlfunctions_vs_excel\days_test.py .                                                                        [ 25%]
tests\xlfunctions_vs_excel\double_minus_test.py ...                                                              [ 26%]
tests\xlfunctions_vs_excel\dynamic_range_test.py FFFFFFFFFFFFFFFFFFFFFFFFFFFF                                    [ 35%]
tests\xlfunctions_vs_excel\edate_test.py ...                                                                     [ 36%]
tests\xlfunctions_vs_excel\engineering_test.py ..                                                                [ 37%]
tests\xlfunctions_vs_excel\eomonth_test.py ..                                                                    [ 38%]
tests\xlfunctions_vs_excel\exact_test.py ....                                                                    [ 39%]
tests\xlfunctions_vs_excel\find_test.py ......                                                                   [ 41%]
tests\xlfunctions_vs_excel\if_test.py .                                                                          [ 41%]
tests\xlfunctions_vs_excel\information_comprehensive_test.py F................................                   [ 52%]
tests\xlfunctions_vs_excel\information_test.py .........                                                         [ 55%]
tests\xlfunctions_vs_excel\int_test.py .                                                                         [ 55%]
tests\xlfunctions_vs_excel\irr_test.py ...                                                                       [ 56%]
tests\xlfunctions_vs_excel\len_test.py ...                                                                       [ 57%]
tests\xlfunctions_vs_excel\ln_test.py ..                                                                         [ 58%]
tests\xlfunctions_vs_excel\logical_test.py FFFFFFFFFFFFFFFFFF                                                    [ 63%]
tests\xlfunctions_vs_excel\match_test.py ...                                                                     [ 64%]
tests\xlfunctions_vs_excel\math_comprehensive_test.py ...................                                        [ 70%]
tests\xlfunctions_vs_excel\max_test.py ..                                                                        [ 71%]
tests\xlfunctions_vs_excel\mid_test.py ...                                                                       [ 72%]
tests\xlfunctions_vs_excel\min_test.py ..                                                                        [ 73%]
tests\xlfunctions_vs_excel\mod_test.py ....                                                                      [ 74%]
tests\xlfunctions_vs_excel\month_test.py .                                                                       [ 74%]
tests\xlfunctions_vs_excel\not_test.py .                                                                         [ 75%]
tests\xlfunctions_vs_excel\npv_test.py ..                                                                        [ 75%]
tests\xlfunctions_vs_excel\pmt_test.py ...                                                                       [ 76%]
tests\xlfunctions_vs_excel\power_test.py ...                                                                     [ 77%]
tests\xlfunctions_vs_excel\right_test.py ..                                                                      [ 78%]
tests\xlfunctions_vs_excel\round_test.py .......                                                                 [ 80%]
tests\xlfunctions_vs_excel\rounddown_test.py .....                                                               [ 82%]
tests\xlfunctions_vs_excel\roundup_test.py .....                                                                 [ 83%]
tests\xlfunctions_vs_excel\sln_test.py .                                                                         [ 83%]
tests\xlfunctions_vs_excel\sqrt_test.py ...                                                                      [ 84%]
tests\xlfunctions_vs_excel\sum_test.py .                                                                         [ 85%]
tests\xlfunctions_vs_excel\sumifs_test.py .                                                                      [ 85%]
tests\xlfunctions_vs_excel\sumproduct_test.py .                                                                  [ 85%]
tests\xlfunctions_vs_excel\test_logical.py FFFFFF                                                                [ 87%]
tests\xlfunctions_vs_excel\text_comprehensive_test.py .............                                              [ 91%]
tests\xlfunctions_vs_excel\vlookup_test.py ..                                                                    [ 92%]
tests\xlfunctions_vs_excel\xlookup_test.py ..FF......FFFF.                                                       [ 97%]
tests\xlfunctions_vs_excel\xnpv_test.py .                                                                        [ 97%]
tests\xlfunctions_vs_excel\year_test.py ....                                                                     [ 99%]
tests\xlfunctions_vs_excel\yearfrac_test.py ...                                                                  [100%]

====================================================== FAILURES =======================================================
____________________________________ DynamicRangeTest.test_index_basic_cell_access ____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
______________________________________ DynamicRangeTest.test_index_boolean_value ______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
__________________________________ DynamicRangeTest.test_index_column_out_of_bounds ___________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
______________________________________ DynamicRangeTest.test_index_entire_column ______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________________ DynamicRangeTest.test_index_entire_row ________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
______________________________________ DynamicRangeTest.test_index_header_access ______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________________ DynamicRangeTest.test_index_name_lookup _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
____________________________________ DynamicRangeTest.test_index_row_out_of_bounds ____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
______________________________________ DynamicRangeTest.test_index_score_lookup _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
________________________________ DynamicRangeTest.test_indirect_another_cell_reference ________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________ DynamicRangeTest.test_indirect_another_direct_reference _______________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
____________________________________ DynamicRangeTest.test_indirect_cell_reference ____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
________________________________ DynamicRangeTest.test_indirect_direct_range_reference ________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________ DynamicRangeTest.test_indirect_direct_string_reference ________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
________________________________ DynamicRangeTest.test_indirect_empty_reference_error _________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________ DynamicRangeTest.test_indirect_invalid_reference_error ________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________ DynamicRangeTest.test_indirect_range_reference ____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________ DynamicRangeTest.test_indirect_score_reference ____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_____________________________________ DynamicRangeTest.test_nested_index_indirect _____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
____________________________________ DynamicRangeTest.test_nested_indirect_offset _____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
____________________________________ DynamicRangeTest.test_offset_basic_reference _____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________ DynamicRangeTest.test_offset_diagonal_movement ____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
__________________________________ DynamicRangeTest.test_offset_horizontal_movement ___________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
____________________________________ DynamicRangeTest.test_offset_larger_movement _____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_________________________________ DynamicRangeTest.test_offset_negative_column_error __________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________ DynamicRangeTest.test_offset_negative_row_error ___________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________ DynamicRangeTest.test_offset_range_from_origin ____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________ DynamicRangeTest.test_offset_with_height_width ____________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAMIC_RANGE.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________ InformationComprehensiveTest.test_isblank_empty_string ________________________________

self = <tests.xlfunctions_vs_excel.information_comprehensive_test.InformationComprehensiveTest testMethod=test_isblank_empty_string>

    def test_isblank_empty_string(self):
        """Test ISBLANK with empty string."""
        excel_value = self.evaluator.get_cell_value('Sheet1!D5')
        value = self.evaluator.evaluate('Sheet1!D5')
>       self.assertEqual(excel_value, value)
E       AssertionError: False != True

tests\xlfunctions_vs_excel\information_comprehensive_test.py:89: AssertionError
________________________________________ LogicalTest.test_and_cell_references _________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_____________________________________________ LogicalTest.test_and_empty ______________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
__________________________________________ LogicalTest.test_and_false_false ___________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
______________________________________ LogicalTest.test_and_logical_expressions _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
______________________________________ LogicalTest.test_and_multiple_conditions _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________________ LogicalTest.test_and_true_false ___________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________________ LogicalTest.test_and_true_true ____________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________________ LogicalTest.test_false_constant ___________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
__________________________________________ LogicalTest.test_nested_logical_1 __________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
__________________________________________ LogicalTest.test_nested_logical_2 __________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_________________________________________ LogicalTest.test_or_cell_references _________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
______________________________________________ LogicalTest.test_or_empty ______________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________________ LogicalTest.test_or_false_false ___________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________________ LogicalTest.test_or_logical_expressions _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________________ LogicalTest.test_or_multiple_conditions _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________________ LogicalTest.test_or_true_false ____________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
____________________________________________ LogicalTest.test_or_true_true ____________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________________ LogicalTest.test_true_constant ____________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
______________________________________ LogicalFunctionsTest.test_AND_false_case _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________________ LogicalFunctionsTest.test_AND_true_case _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________________ LogicalFunctionsTest.test_IF_false_case _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________________ LogicalFunctionsTest.test_IF_true_case ________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________________ LogicalFunctionsTest.test_OR_false_case _______________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
_______________________________________ LogicalFunctionsTest.test_OR_true_case ________________________________________
tests\testing.py:109: in setUp
    self.model = compiler.read_and_parse_archive(
xlcalculator\model.py:183: in read_and_parse_archive
    archive = self.read_excel_file(file_name)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
xlcalculator\model.py:167: in read_excel_file
    archive.read()
xlcalculator\reader.py:13: in read
    self.book = openpyxl.load_workbook(self.excel_file_name)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:346: in load_workbook
    reader = ExcelReader(filename, read_only, keep_vba,
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:123: in __init__
    self.archive = _validate_archive(fn)
                   ^^^^^^^^^^^^^^^^^^^^^
C:\Users\agust\miniforge3\envs\xlcalc313\Lib\site-packages\openpyxl\reader\excel.py:95: in _validate_archive
    archive = ZipFile(filename, 'r')
              ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <zipfile.ZipFile [closed]>, file = 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'
mode = 'r', compression = 0, allowZip64 = True, compresslevel = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
>                   self.fp = io.open(file, filemode)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E                   FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logical.xlsx'

C:\Users\agust\miniforge3\envs\xlcalc313\Lib\zipfile\__init__.py:1367: FileNotFoundError
___________________________________ XLookupTest.test_approximate_match_next_largest ___________________________________

self = <tests.xlfunctions_vs_excel.xlookup_test.XLookupTest testMethod=test_approximate_match_next_largest>

    def test_approximate_match_next_largest(self):
        """Test approximate match with next largest."""
        value = self.evaluator.evaluate('Sheet1!A13')
        expected = "D"  # XLOOKUP(15, D2:D6, E2:E6, , 1) -> next largest is 20 -> "D"
>       self.assertEqual(expected, value)
E       AssertionError: 'D' != <Number 1>

tests\xlfunctions_vs_excel\xlookup_test.py:37: AssertionError
__________________________________ XLookupTest.test_approximate_match_next_smallest ___________________________________

self = <tests.xlfunctions_vs_excel.xlookup_test.XLookupTest testMethod=test_approximate_match_next_smallest>

    def test_approximate_match_next_smallest(self):
        """Test approximate match with next smallest."""
        value = self.evaluator.evaluate('Sheet1!A12')
        expected = "D"  # XLOOKUP(25, D2:D6, E2:E6, , -1) -> next smallest is 20 -> "D"
>       self.assertEqual(expected, value)
E       AssertionError: 'D' != <Number -1>

tests\xlfunctions_vs_excel\xlookup_test.py:31: AssertionError
___________________________________________ XLookupTest.test_reverse_search ___________________________________________

self = <tests.xlfunctions_vs_excel.xlookup_test.XLookupTest testMethod=test_reverse_search>

    def test_reverse_search(self):
        """Test reverse search (last occurrence)."""
        value = self.evaluator.evaluate('Sheet1!A21')
        expected = 5  # XLOOKUP("A", G2:G6, H2:H6, , 0, -1) -> last "A" at position 5
>       self.assertEqual(expected, value)
E       AssertionError: 5 != <Number 1>

tests\xlfunctions_vs_excel\xlookup_test.py:73: AssertionError
______________________________________ XLookupTest.test_wildcard_match_asterisk _______________________________________

self = <tests.xlfunctions_vs_excel.xlookup_test.XLookupTest testMethod=test_wildcard_match_asterisk>

    def test_wildcard_match_asterisk(self):
        """Test wildcard matching with asterisk."""
        value = self.evaluator.evaluate('Sheet1!A16')
        expected = 10  # XLOOKUP("App*", A2:A5, B2:B5, , 2) -> matches "Apple" -> 10
>       self.assertEqual(expected, value)
E       AssertionError: 10 != <Number 2>

tests\xlfunctions_vs_excel\xlookup_test.py:49: AssertionError
_______________________________________ XLookupTest.test_wildcard_match_prefix ________________________________________

self = <tests.xlfunctions_vs_excel.xlookup_test.XLookupTest testMethod=test_wildcard_match_prefix>

    def test_wildcard_match_prefix(self):
        """Test wildcard matching with prefix asterisk."""
        value = self.evaluator.evaluate('Sheet1!A18')
        expected = 30  # XLOOKUP("*erry", A2:A5, B2:B5, , 2) -> matches "Cherry" -> 30
>       self.assertEqual(expected, value)
E       AssertionError: 30 != <Number 2>

tests\xlfunctions_vs_excel\xlookup_test.py:61: AssertionError
______________________________________ XLookupTest.test_wildcard_match_question _______________________________________

self = <tests.xlfunctions_vs_excel.xlookup_test.XLookupTest testMethod=test_wildcard_match_question>

    def test_wildcard_match_question(self):
        """Test wildcard matching with question mark."""
        value = self.evaluator.evaluate('Sheet1!A17')
        expected = 20  # XLOOKUP("Ban?na", A2:A5, B2:B5, , 2) -> matches "Banana" -> 20
>       self.assertEqual(expected, value)
E       AssertionError: 20 != <Number 2>

tests\xlfunctions_vs_excel\xlookup_test.py:55: AssertionError
=============================================== short test summary info ===============================================
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_index_basic_cell_access - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_index_boolean_value - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_index_column_out_of_bounds - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_index_entire_column - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_index_entire_row - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_index_header_access - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_index_name_lookup - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_index_row_out_of_bounds - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_index_score_lookup - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_indirect_another_cell_reference - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_indirect_another_direct_reference - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_indirect_cell_reference - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_indirect_direct_range_reference - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_indirect_direct_string_reference - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_indirect_empty_reference_error - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_indirect_invalid_reference_error - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_indirect_range_reference - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_indirect_score_reference - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_nested_index_indirect - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_nested_indirect_offset - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_offset_basic_reference - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_offset_diagonal_movement - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_offset_horizontal_movement - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_offset_larger_movement - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_offset_negative_column_error - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_offset_negative_row_error - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_offset_range_from_origin - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/dynamic_range_test.py::DynamicRangeTest::test_offset_with_height_width - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\DYNAM...
FAILED tests/xlfunctions_vs_excel/information_comprehensive_test.py::InformationComprehensiveTest::test_isblank_empty_string - AssertionError: False != True
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_and_cell_references - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_and_empty - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_and_false_false - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_and_logical_expressions - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_and_multiple_conditions - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_and_true_false - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_and_true_true - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_false_constant - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_nested_logical_1 - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_nested_logical_2 - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_or_cell_references - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_or_empty - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_or_false_false - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_or_logical_expressions - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_or_multiple_conditions - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_or_true_false - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_or_true_true - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/logical_test.py::LogicalTest::test_true_constant - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/test_logical.py::LogicalFunctionsTest::test_AND_false_case - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/test_logical.py::LogicalFunctionsTest::test_AND_true_case - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/test_logical.py::LogicalFunctionsTest::test_IF_false_case - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/test_logical.py::LogicalFunctionsTest::test_IF_true_case - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/test_logical.py::LogicalFunctionsTest::test_OR_false_case - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/test_logical.py::LogicalFunctionsTest::test_OR_true_case - FileNotFoundError: [Errno 2] No such file or directory: 'c:\\workspace_local\\xlcalculator\\tests\\resources\\logic...
FAILED tests/xlfunctions_vs_excel/xlookup_test.py::XLookupTest::test_approximate_match_next_largest - AssertionError: 'D' != <Number 1>
FAILED tests/xlfunctions_vs_excel/xlookup_test.py::XLookupTest::test_approximate_match_next_smallest - AssertionError: 'D' != <Number -1>
FAILED tests/xlfunctions_vs_excel/xlookup_test.py::XLookupTest::test_reverse_search - AssertionError: 5 != <Number 1>
FAILED tests/xlfunctions_vs_excel/xlookup_test.py::XLookupTest::test_wildcard_match_asterisk - AssertionError: 10 != <Number 2>
FAILED tests/xlfunctions_vs_excel/xlookup_test.py::XLookupTest::test_wildcard_match_prefix - AssertionError: 30 != <Number 2>
FAILED tests/xlfunctions_vs_excel/xlookup_test.py::XLookupTest::test_wildcard_match_question - AssertionError: 20 != <Number 2>
=========================================== 59 failed, 253 passed in 10.47s ===========================================