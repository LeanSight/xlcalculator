# Lazy Loading Design Alternatives - ATDD Approach

## Problem Statement
- **Current**: `Data!A:A` loads 1,048,576 cells (13.7s, 2M+ memory)
- **Needed**: Only 6 cells have actual data
- **Goal**: Load data on-demand while maintaining Excel compatibility

## Design Alternatives

### Alternative 1: Range Virtualization
**Concept**: Create virtual ranges that load data only when accessed

```python
class VirtualRange:
    def __init__(self, sheet, start_col, end_col, start_row=1, end_row=1048576):
        self.sheet = sheet
        self.start_col, self.end_col = start_col, end_col
        self.start_row, self.end_row = start_row, end_row
        self._loaded_chunks = {}  # Cache for loaded data
        
    def get_cell(self, row, col):
        # Load only the chunk containing this cell
        chunk_key = (row // 1000, col)  # 1000-row chunks
        if chunk_key not in self._loaded_chunks:
            self._load_chunk(chunk_key)
        return self._loaded_chunks[chunk_key].get((row, col))
```

**Pros**: 
- Minimal memory usage
- Fast initial loading
- Granular control

**Cons**: 
- Complex implementation
- Potential compatibility issues
- Cache management overhead

### Alternative 2: Smart Range Detection
**Concept**: Detect full column/row references and replace with bounded ranges

```python
class SmartRangeResolver:
    def resolve_range(self, range_ref):
        if self._is_full_column(range_ref):
            # Find actual data bounds
            actual_bounds = self._find_data_bounds(range_ref)
            return self._create_bounded_range(range_ref, actual_bounds)
        return range_ref
        
    def _find_data_bounds(self, range_ref):
        # Scan for last non-empty cell efficiently
        # Use binary search or sampling
        pass
```

**Pros**: 
- Transparent to existing code
- Excel-compatible behavior
- Simple implementation

**Cons**: 
- Still requires scanning for bounds
- May miss sparse data
- One-time cost during resolution

### Alternative 3: Lazy Range Proxy
**Concept**: Create proxy objects that behave like loaded ranges but load on access

```python
class LazyRangeProxy:
    def __init__(self, evaluator, range_ref):
        self.evaluator = evaluator
        self.range_ref = range_ref
        self._cache = {}
        self._bounds = None
        
    def __getitem__(self, index):
        if index not in self._cache:
            self._cache[index] = self._load_cell(index)
        return self._cache[index]
        
    def values(self):
        # Load only when .values is accessed
        if self._bounds is None:
            self._bounds = self._determine_bounds()
        return self._load_bounded_data()
```

**Pros**: 
- Drop-in replacement
- Maintains interface compatibility
- Efficient memory usage

**Cons**: 
- Requires interface changes
- Complex proxy behavior
- Potential edge cases

### Alternative 4: Hybrid Approach (RECOMMENDED)
**Concept**: Combine smart detection with lazy loading for optimal balance

```python
class HybridRangeManager:
    def __init__(self, evaluator):
        self.evaluator = evaluator
        self._range_cache = {}
        self._bounds_cache = {}
        
    def get_range_values(self, range_ref):
        # Step 1: Check if it's a problematic full range
        if self._is_full_range(range_ref):
            return self._handle_full_range_lazy(range_ref)
        
        # Step 2: Use normal loading for bounded ranges
        return self._load_normal_range(range_ref)
        
    def _handle_full_range_lazy(self, range_ref):
        # Find actual data bounds efficiently
        bounds = self._get_cached_bounds(range_ref)
        if bounds is None:
            bounds = self._scan_for_bounds(range_ref)
            self._bounds_cache[range_ref] = bounds
            
        # Load only the bounded data
        bounded_ref = self._create_bounded_reference(range_ref, bounds)
        return self._load_normal_range(bounded_ref)
```

**Pros**: 
- Best of all approaches
- Minimal code changes
- Excel-compatible
- Performance optimized

**Cons**: 
- Moderate complexity
- Requires careful bounds detection

## ATDD Test Design

### Test 1: Performance Validation
```python
def test_lazy_loading_performance():
    """Validate that lazy loading improves performance significantly"""
    start_time = time.time()
    
    # This should be fast with lazy loading
    evaluator = create_evaluator('special_references.xlsx')
    setup_time = time.time() - start_time
    
    # Should be < 1 second instead of 14 seconds
    assert setup_time < 1.0, f"Setup took {setup_time}s, expected < 1s"
    
    # Formulas should still work correctly
    assert evaluator.evaluate('Tests!Q2') == 'Alice'
    assert evaluator.evaluate('Tests!Q3').values[0][0] == 'Alice'
```

### Test 2: Excel Compatibility
```python
def test_excel_compatibility():
    """Ensure lazy loading maintains Excel-compatible behavior"""
    evaluator = create_evaluator('special_references.xlsx')
    
    # Test INDEX with full column
    result = evaluator.evaluate('=INDEX(Data!A:A, 2)')
    assert result == 'Alice'  # Same as Excel
    
    # Test OFFSET with full column  
    result = evaluator.evaluate('=OFFSET(Data!A:A, 1, 0, 3, 1)')
    expected = ['Alice', 'Bob', 'Charlie']
    assert result.values.flatten().tolist() == expected
```

### Test 3: Memory Efficiency
```python
def test_memory_efficiency():
    """Validate that memory usage is reasonable"""
    import psutil
    import os
    
    process = psutil.Process(os.getpid())
    initial_memory = process.memory_info().rss
    
    evaluator = create_evaluator('special_references.xlsx')
    
    final_memory = process.memory_info().rss
    memory_increase = final_memory - initial_memory
    
    # Should use < 50MB instead of 500MB+
    assert memory_increase < 50 * 1024 * 1024, f"Used {memory_increase/1024/1024:.1f}MB"
```

## Implementation Priority

1. **Phase 1**: Implement Alternative 4 (Hybrid) for `get_range_values`
2. **Phase 2**: Add bounds detection and caching
3. **Phase 3**: Extend to model loading optimization
4. **Phase 4**: Add configuration options for lazy loading behavior

## Success Criteria

- ✅ Setup time: 14s → < 1s (14x improvement)
- ✅ Memory usage: 2M+ cells → < 1000 cells (2000x improvement)  
- ✅ Excel compatibility: All existing tests pass
- ✅ Code maintainability: Clean, well-documented implementation
- ✅ Performance: No regression for normal ranges